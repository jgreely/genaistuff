#!/usr/bin/env python
"""
A script that uses the SwarmUI API to generate images based on
parameters taken from a mix of command-line options, canned
modifications, JSON files, and metadata from previous
SwarmUI-generated images.

TODO: switch to click.echo for handling Unicode properly under Windows;
    lots of goofy filenames generated by swarmui from model metadata

TODO: more commands to implement

sui [opt] list-params [search]
    list-params - valid image-gen parameters, filtered by search string
"""

import io
import os
import sys
import base64
import configparser
import json
import exiftool
import click
import requests
from requests.exceptions import HTTPError
from PIL import Image
from PIL.PngImagePlugin import PngInfo
import math
import importlib.resources
from string import Template
from datetime import datetime

# canned sets of parameters; override by creating ~/.sui
# 
default_rules = """
# 'rounding' field is used internally to calculate the resolutions
# for aspect ratios (most models prefer resolutions where X and Y
# are divisible by 64), and is not passed to SwarmUI.
# 'fix_resolution' field is used internally to round up the requested
# resolution to /64 and then crop it after image generation.
#
#[DEFAULT]
#host = remoteswarm.example.com
#port = 9999
#
[sdxl]
model=sd_xl_base_1.0
cfgscale=6.5
steps=36
sidelength=1024
rounding=64
sampler=dpmpp_2m_sde_gpu
scheduler=beta

[zit]
model = z_image_turbo_bf16
steps= 9
cfgscale = 1.0
sidelength=1024
rounding=64
sampler = euler_ancestral
scheduler = simple
sigmashift = 3.0
fix_resolution = true

[512]
sidelength=512
rounding=16

[768]
sidelength=768
rounding=16

[2k]
sidelength=1472
rounding=64

[2x]
refinercontrolpercentage = 0.4
refinermethod = PostApply
refinerupscale = 2.0
# recommended: model-4xNomosUniDAT_bokeh_jpg_-_v2-0
refinerupscalemethod = pixel-lanczos
refinersampler = seeds_2
refinerscheduler = kl_optimal
refinerdotiling = true

[vary15]
variationseed = -1
variationseedstrength = 0.15
"""

class swarmui:
    """simple API wrapper for SwarmUI"""
    def __init__(self, *, host:str, port:str):
        self._headers = {
            'user-agent': 'sui/1.0.0',
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
        self._config = configparser.RawConfigParser()
        config_file = os.path.join(os.path.expanduser("~"), ".sui")
        if os.path.isfile(config_file):
            self._config.read(config_file)
        else:
            self._config.read_string(default_rules)
        if host:
            self._host = host
        elif self._config.has_option('DEFAULT', 'host'):
            self._host = self._config.get('DEFAULT', 'host')
        else:
            self._host = 'localhost'
        if port:
            self._port = port
        elif self._config.has_option('DEFAULT', 'port'):
            self._port = self._config.get('DEFAULT', 'port')
        else:
            self._port = '7801'

    @property
    def baseurl(self):
        return f"http://{self.host}:{self.port}"

    def _get_host(self):
        return self._host
    def _set_host(self, value):
        self._host = value
    host = property(_get_host, _set_host)
    def _get_port(self):
        return self._port
    def _set_port(self, value):
        self._port = value
    port = property(_get_port, _set_port)

    def create_session(self):
        response = self._post("/API/GetNewSession", params={})
        self._change_usersettings(session=response['session_id'])
        return response['session_id']

    def generate_image(self, params:dict, *, outfile="sui-output.png",
        session:str):
        params['session_id'] = session
        params['images'] = 1
        if 'imageformat' not in params:
            params['imageformat'] = 'PNG'
        if 'save_on_server' not in self.params:
            params['donotsave'] = True
        for noise in ['swarm_version', 'rounding', 'fix_resolution', 'host', 'port']:
            if noise in params:
                del params[noise]
        for fixup in ['loras', 'loraweights', 'loratencweights', 'lorasectionconfinement']:
            if fixup in params:
                _array2str(params, fixup)
        response = self._post("/API/GenerateText2Image", params=params,
            timeout=3600)
        imagefile = response['images'][0]
        if 'personalnote' in params:
            source = params['personalnote']
        else:
            source = ""
        self._download_image(imagefile, outfile, source)
        return(outfile)

    def list_rules(self):
        return self._config.sections()

    def get_rule_params(self, rule:str):
        if self._config.has_section(rule):
            items = dict(self._config.items(section=rule))
            return items
        print(f"Warning: config file has no rule '{rule}'")
        return dict()

    def merge_params(self, sets:list):
        """merge multiple sets of parameters into one, keeping the last version of each key"""
        params = dict()
        for set in sets:
            for item in set:
                if set[item] == 'unset':
                    del params[item]
                else:
                    params[item] = set[item]
        return params

    def get_models(self, *, type='Stable-Diffusion', session:str):
        """retrieve the names of available models (base, lora, vae)"""
        params = {
            "session_id": session,
            "path": "",
            "depth": 4,
            "subtype": type # Stable-Diffusion, LoRA, VAE
        }
        response = self._post("/API/ListModels", params=params)
        return response['files']


    def _get(self, call:str, *, timeout=30):
        """Send GET request to a SwarmUI endpoint"""
        url = f"{self.baseurl}{call}"
        try:
            response = requests.get(url, timeout=timeout)
            response.raise_for_status()
        except requests.exceptions.RequestException as err:
            raise SystemExit(err)
        return response

    def _post(self, call:str, *, params:dict, timeout=5):
        """Send POST request with JSON parameters to a SwarmUI endpoint"""
        url = f"{self.baseurl}{call}"
        try:
            response = requests.post(url, json=params, headers=self._headers,
                timeout=timeout)
            response.raise_for_status()
        except requests.exceptions.RequestException as err:
            raise SystemExit(err)
        if 'error' in response.json():
            print(f"{call} failed: {response.json()['error']}")
        return response.json()

    # Warning: this API call always returns success; you *must* check
    # the server logs for failures.
    def _change_usersettings(self, *, session:str):
        """force specific filename format, as PNG, with metadata"""
        params = {
            'session_id': session,
            'settings': {
                'fileformat.reformattransientimages': True,
                'fileformat.savemetadata': True
            }
        }
        response = self._post("/API/ChangeUserSettings", params=params)

    def _download_image(self, imagefile:str, outputfile:str, source:str):
        """download generated image from SwarmUI server"""
        if 'base64' in imagefile:
            b64 = imagefile.split(',')[1]
            img = base64.b64decode(b64)
            img_stream = io.BytesIO(img)
        else:
            img_stream = io.BytesIO()
            response = self._get(f"/{imagefile}")
            for chunk in response.iter_content(chunk_size=16*1024):
                img_stream.write(chunk)
        output = Image.open(img_stream)
        exif = output.getexif()
        meta = output.info
        newmeta = PngInfo()
        if 'parameters' in meta:
            newmeta.add_text('parameters', meta['parameters'])
        if self.crop:
            output = output.crop(self.crop)
        if source:
            exif[269] = source # DocumentName
        if output.format == 'JPEG':
            output.save(outputfile, exif=exif)
        else:
            output.save(outputfile, exif=exif, pnginfo=newmeta)

def get_file_params(file:str, verbose=False):
    """load image params from either a JSON file or image metadata"""
    base, ext = os.path.splitext(file)
    if ext.lower() == '.json':
        with open(file, "r") as jfile:
            return json.load(jfile)
    elif ext.lower() in ['.png', '.jpg', '.jpeg']:
        with Image.open(file) as image:
            metadata = image.info
            params = dict()
            if image.format == 'PNG':
                if 'parameters' in metadata:
                    p = metadata["parameters"]
                    if j := json.loads(p):
                        if sui := j["sui_image_params"]:
                            params = sui
                        if verbose:
                            params = j
            elif image.format == 'JPEG':
                metadata = exiftool.ExifToolHelper().get_metadata(file)[0]
                if 'EXIF:UserComment' in metadata:
                    if j := json.loads(metadata['EXIF:UserComment']):
                        if sui := j["sui_image_params"]:
                            params = sui
                        if verbose:
                            params = j
            else:
                print(f"{file}: no SwarmUI metadata found")
        return params
    else:
        print(f"{file}: unknown file type")

# swarmui request format is slightly different from returned metadata
# (array fields: loras, loraweights, lorasectionconfinement)
# 
def _array2str(d:dict, k:str):
    """convert d[k] from list to comma-separated string"""
    if type(d[k]) is list:
        d[k] = ','.join(d[k])
def _str2array(d:dict, k:str):
    """convert d[k] from comma-separated string to list"""
    if type(d[k]) is str:
        d[k] = d[k].split(',')


@click.group()
@click.option('-h', '--host', default='',
    help='server name or IP address')
@click.option('-p', '--port', default='',
    help='port server is listening on')
@click.option('-a', '--aspect', type=str,
    help='aspect ratio as X:Y or as specific XxY pixel resolution')
@click.option('-s', '--sidelength', default='1024/64',
    help='model sidelength as pixels/divisor (default 1024/64)')
@click.option('-f', '--fix-resolution', is_flag=True,
    help='''
        round XxY resolution up to nearest /64, then crop after generating;
        this avoids visual artifacts at image edges for certain models
    ''')
@click.option('-t', '--template', default='$pre-$set-$seq.$ext',
    help="""
        filename template for generated images (default "$pre-$set-$seq.$ext").
        The following variables are available: pre, set, seq, ext, ymd, hms.
    """)
@click.option('--pre', default='genai',
    help='template variable "pre"')
@click.option('--set', default='img',
    help='template variable "set"')
@click.option('--seq', default=1,
    help='template variable "seq" initial value (auto-increments)')
@click.option('--pad', default=4,
    help='zero-padding length for "seq" (default 4)')
def cli(host, port, aspect, sidelength, pre, set, seq, pad, template,
    fix_resolution):
    pass


@cli.command()
@click.option('-m', '--model', type=str,
    help='base model to render images with')
@click.option('-l', '--loras', type=str, multiple=True,
    help='LoRA models to add (add ":0.x" to set strength < 1)')
@click.option('-r', '--rules', multiple=True,
    help='config-file parameter set (overrides file params)')
@click.option('-p', '--params', multiple=True,
    help='''
        comma-separated list of SwarmUI parameters and values as p=v
        (overrides file params and rules)
    ''')
@click.option('-s', '--save-on-server', is_flag=True,
    help='''
        tell SwarmUI to save the generated images; by default,
        only the downloaded copy will exist.
    ''')
@click.option('-j', '--jpeg-output', is_flag=True,
    help='tell SwarmUI to generate JPG output instead of PNG')
@click.option('-n', '--dry-run', is_flag=True,
    help='just print the arguments that would be used to generate images')
@click.argument('sources', nargs=-1)
@click.pass_context
def gen(ctx, model, loras, params, rules, sources, dry_run, save_on_server, jpeg_output):
    """
    Generate images with common parameters and different prompts.

    If an argument is a filename, read all metadata from it (accepts PNG
    and JSON files) and use as params for generating an image.

    If one or more non-file arguments are passed, use them as separate
    prompts, and generate one image for each.

    If no arguments are passed, read prompts from STDIN and generate
    one image for each.
    """        

    s = swarmui(
        host=ctx.parent.params['host'],
        port=ctx.parent.params['port']
    )
    s.params = ctx.parent.params
    session_id = s.create_session()
    if sources:
        images = list(sources)
    else:
        images = sys.stdin.readlines()
    seq = s.params['seq']
    for image in images:
        if os.path.isfile(image):
            image_params = get_file_params(image)
            # store original filename in metadata (transferred to EXIF)
            image_params['personalnote'] = os.path.basename(image)
        else:
            image_params = { "prompt": image.rstrip() }
        if rules:
            for rule_arg in rules:
                for rule in rule_arg.split(','):
                    image_params = s.merge_params([image_params,
                        s.get_rule_params(rule)])
        if params:
            for param_arg in params:
                for param in param_arg.split(','):
                    k, v = param.split('=')
                    image_params[k] = v
        if model:
            image_params['model'] = model
        if loras:
            if 'loras' not in image_params:
                image_params['loras'] = list()
            if 'loraweights' not in image_params:
                image_params['loraweights'] = list()
            for lora in loras:
                loraweight = "1"
                if ':' in lora:
                    lora, loraweight = lora.split(':')
                image_params['loras'].append(lora)
                image_params['loraweights'].append(loraweight)
        if s.params['aspect']:
            if s.params['sidelength']:
                if '/' in s.params['sidelength']:
                    sidelength, rounding = s.params['sidelength'].split('/')
                else:
                    sidelength = s.params['sidelength']
                    rounding = 64
                sidelength = int(sidelength)
            elif image_params['sidelength']:
                sidelength = int(image_params['sidelength'])
                if image_params['rounding']:
                    rounding = image_params['rounding']
                else:
                    rounding = 64
            width, height = get_aspect_pixels(s.params['aspect'],
                side=sidelength, rounding=int(rounding))
            image_params['width'] = width
            image_params['height'] = height
        s.crop = ()
        if image_params['fix_resolution']:
            old_w = int(image_params['width'])
            old_h = int(image_params['height'])
            if old_w % 64 > 0:
                new_w = (old_w // 64 + 1) * 64
            else:
                new_w = old_w
            if old_h % 64 > 0:
                new_h = (old_h // 64 + 1) * 64
            else:
                new_h = old_h
            if new_w > old_w or new_h > old_h:
                delta_w = (new_w - old_w) // 2;
                delta_h = (new_h - old_h) // 2;
                s.crop = (delta_w, delta_h, old_w + delta_w, old_h + delta_h)
                if 'refinerupscale' in image_params:
                    mul = float(image_params['refinerupscale'])
                    s.crop = tuple([int(mul * i) for i in s.crop])
                image_params['width'] = new_w
                image_params['height'] = new_h
        if jpeg_output:
            ext = 'jpg'
            image_params['imageformat'] = 'JPG'
        else:
            ext = 'png'
        outname = format_filename(pre=s.params['pre'],
            set=s.params['set'], pad=s.params['pad'], seq=seq,
            template=ctx.parent.params['template'], ext=ext)
        if dry_run:
            print(f"output file: {outname}")
            print(f"session_id: {session_id}")
            print(json.dumps(image_params, indent=4))
        else:
            image = s.generate_image(image_params, session=session_id,
                outfile=outname)
            print(outname)
        seq += 1
    
@cli.command()
@click.option('-j', '--json', 'json_output', is_flag=True,
    help='generate JSON output instead of default K=V')
@click.option('-v', '--verbose', is_flag=True,
    help='includes all metadata; implies --json')
@click.option('-p', '--prompt', is_flag=True,
    help='print just the prompt(s), one per line')
@click.argument('files', nargs=-1)
@click.pass_context
def params(ctx, json_output, verbose, prompt, files):
    """dump parameters from JSON, PNG, and JPG files"""
    if verbose:
        json_output = True
    output = list()
    for file in files:
        params = get_file_params(file, verbose)
        if params:
            if prompt:
                print(params['prompt'])
            elif json_output:
                params['_filename'] = file
                output.append(params)
            else:
                print(f'filename={file}')
                for k in params:
                    print(f'{k}={params[k]}')
                if len(files) > 1:
                    print()
    if output:
        if len(output) > 1:
            print(json.dumps(output, sort_keys=True, indent=4))
        else:
            print(json.dumps(output[0], sort_keys=True, indent=4))

@cli.command()
@click.argument('files', nargs=-1)
@click.pass_context
def prompt(ctx, files):
    """shortcut for 'params -p'"""
    for file in files:
        params = get_file_params(file)
        if params:
            print(params['prompt'])

@cli.command()
@click.option('-v', '--verbose', is_flag=True,
    help='print contents of all rules for ~/.sui')
@click.pass_context
def list_rules(ctx, verbose):
    """list all rules defined in ~/.sui or default config"""
    s = swarmui()
    for rule in s.list_rules():
        if verbose:
            print(f"[{rule}]")
            keys = s.get_rule_params(rule)
            for k in keys:
                print(f"{k}={keys[k]}")
            print()
        else:
            print(rule)

@cli.command()
@click.option('-t', '--type', default='base', 
    help='model type (default "base")',
    type=click.Choice(['base', 'lora', 'vae']))
@click.option('-v', '--verbose', is_flag=True,
    help='print more detail about each model')
@click.argument('search', nargs=-1)
@click.pass_context
def list_models(ctx, type, verbose, search):
    """print list of available models"""
    subtype = 'Stable-Diffusion'
    match type:
        case 'lora':
            subtype = 'LoRA'
        case 'vae':
            subtype = 'VAE'
    s = swarmui(
        host=ctx.parent.params['host'],
        port=ctx.parent.params['port']
    )
    s.params = ctx.parent.params
    session_id = s.create_session()
    for model in s.get_models(type=subtype, session=session_id):
        found = True
        if search:
            found = False
            for key in ['name', 'architecture', 'compat_class']:
                if model[key] and search[0].casefold() in model[key].casefold():
                    found = True
        if found:
            if verbose:
                print(model['title'])
                for key in ['name', 'architecture', 'compat_class', 'resolution']:
                    if key in model:
                        print("    ", model[key])
            else:
                print(os.path.splitext(model['name'])[0])

@cli.command()
@click.option('-n', '--dry-run', is_flag=True,
    help='just print the before/after filenames')
@click.argument('files', nargs=-1)
@click.pass_context
# TODO: add format override
def rename(ctx, dry_run, files):
    """
    rename files to use a consistent format based on --pre|set|seq;
    preserves existing file extension.
    """
    params = ctx.parent.params
    seq = params['seq']
    for file in files:
        base, ext = os.path.splitext(file)
        ext = ext.removeprefix('.')
        outname = format_filename(pre=params['pre'],
            set=params['set'], pad=params['pad'], seq=seq, ext=ext,
            template=ctx.parent.params['template'])
        if dry_run:
            print(file, outname)
        else:
            try:
                os.rename(file, outname)
            except Exception as e:
                print(f"rename '{file}' to '{outname}: {e}")
        seq += 1


@cli.command()
@click.option('-n', '--dry-run', is_flag=True,
    help='just print the before/after filenames')
@click.option('-r', '--resize', default=100,
    help='percentage to resize image to (default: no change)')
@click.argument('files', nargs=-1)
@click.pass_context
def jpg(ctx, dry_run, resize, files):
    """convert PNG files to JPG, preserving metadata and optionally resizing"""
    for file in files:
        if os.path.isfile(file):
            params = get_file_params(file, True)
            with Image.open(file) as image:
                base, ext = os.path.splitext(file)
                outname = f"{base}.jpg"
                if resize < 100:
                    image = image.resize((int(image.width * resize/100),
                    int(image.height * resize/100)))
                if dry_run:
                    print(file, outname)
                else:
                    try:
                        image.save(outname, 'JPEG', optimize=True,
                            quality=85, progressive=True )
                    except Exception as e:
                        print(f"convert/save '{file}' to '{outname}': {e}")
                        sys.exit()
                    exiftool.ExifToolHelper().set_tags(outname,
                        {'EXIF:UserComment': json.dumps(params)},
                        params=['-overwrite_original', '-preserve'])


@cli.command()
@click.pass_context
def status(ctx):
    "return server/backend status"
    s = swarmui(
        host=ctx.parent.params['host'],
        port=ctx.parent.params['port']
    )
    session_id = s.create_session()
    response = s._post("/API/GetCurrentStatus",
        params={'session_id': session_id})
    print(json.dumps(response['status'], indent=4))
    print(json.dumps(response['backend_status'], indent=4))

def format_filename(*, pre="swarmui", set="img", seq=1,
    pad=4, ext="png", template:str):
    """return a consistently-formatted filename for a sequenced image"""
    if template:
        now = datetime.now()
        # TODO: add more filename-formatting variables
        return Template(template).safe_substitute({
            'pre': pre,
            'set': set,
            'seq': str(seq).zfill(pad),
            'ext': ext,
            'ymd': now.strftime('%Y%m%d'),
            'hms': now.strftime('%H%M%S')
        })
    else:
        return f"{pre}-{set}-{seq}.{ext}"


def get_aspect_pixels(ratio:str, *, side=1024, rounding=64):
    """calculate best XxY-pixel approximation for aspect ratio"""
    if 'x' in ratio:
        # user requested specific width x height
        width, height = [int(x) for x in ratio.split('x')]
        return width, height
    elif ':' not in ratio:
        a_w = 1.0
        a_h = 1.0
    else:
        a_w, a_h = [int(x) for x in ratio.split(':')]
    scale = math.sqrt(side * side / (a_w * a_h))
    ideal_w = a_w * scale
    ideal_h = a_h * scale
    width = int(ideal_w) - (int(ideal_w) % rounding)
    height = int(ideal_h) - (int(ideal_h) % rounding)
    while width * height > side * side and width > 0 and height > 0:
        if width >= height:
            width -= rounding
        else:
            height -= rounding
    return width, height


if __name__ == '__main__':
    cli()
