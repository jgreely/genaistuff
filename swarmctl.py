#!/usr/bin/env python
"""
A script that uses the SwarmUI API to generate images based on
parameters taken from a mix of command-line options, canned
modifications, JSON files, and metadata from previous
SwarmUI-generated images.

TODO: switch to click.echo for handling Unicode properly under Windows;
    lots of goofy filenames generated by swarmui from model metadata

TODO: more commands to implement
swarmctl [opt] list-params [search]
    list-params - valid image-gen parameters, filtered by search string

swarmctl [opt] tojpg -r 50 -q high *.png
    -q|--quality set JPEG quality (Pillow presets high|med|low|etc)
    -r|--resize% (Pillow Image.resize(int(im.width * scale/100),
         int(im.height * scale/100))) # not recommended for upscaling
    -s|--strip remove all metadata (default transfers SwarmUI metadata)

Global options:
    -o|--outformat "PNG|JPG" request specific format from server
    -f filename format (simple variable substitution using Template)
        from string import Template
        print(Template('$pre-${set}-$seq.$ext').safe_substitute({
            'pre': 'prefix',
            'set': 'set',
            'ext': 'png',
            # updated for each image
            'ymd': '20251122',
            'hms': '140412',
            'seq': '0005' # 0-padded to 4 by default
        }))

"""

import os
import sys
import configparser
import json
import click
import requests
from requests.exceptions import HTTPError
from PIL import Image
import exifread
import math
import importlib.resources

# canned sets of parameters; override by creating ~/.swarmctl
# 
default_rules = """
# 'rounding' field is used internally to calculate the resolutions
# for aspect ratios (most models prefer resolutions where X and Y
# are divisible by 64), and is not passed to SwarmUI
#
[sdxl]
model=sd_xl_base_1.0
cfgscale=6.5
steps=36
sidelength=1024
rounding=64
sampler=dpmpp_2m_sde_gpu
scheduler=beta

[zit]
model = z_image_turbo_bf16
steps= 9
cfgscale = 1.0
sidelength=1024
rounding=64
sampler = euler_ancestral
scheduler = simple
sigmashift = 3.0

[512]
sidelength=512
rounding=16

[768]
sidelength=768
rounding=16

[2k]
sidelength=1472
rounding=64

[2x]
refinercontrolpercentage = 0.4
refinermethod = PostApply
refinerupscale = 2.0
# recommended: model-4xNomosUniDAT_bokeh_jpg_-_v2-0
refinerupscalemethod = pixel-lanczos
refinersampler = seeds_2
refinerscheduler = kl_optimal
refinerdotiling = true

[vary15]
variationseed = -1
variationseedstrength = 0.15
"""

class swarmui:
    """simple API wrapper for SwarmUI"""
    def __init__(self, *, host = 'localhost', port = '7801'):
        self._host = host
        self._port = port
        self._headers = {
            'user-agent': 'swarmctl/1.0.0',
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
        self._config = configparser.RawConfigParser()
        config_file = os.path.join(os.path.expanduser("~"), ".swarmctl")
        if os.path.isfile(config_file):
            self._config.read(config_file)
        else:
            self._config.read_string(default_rules)

    @property
    def baseurl(self):
        return f"http://{self.host}:{self.port}"

    def _get_host(self):
        return self._host
    def _set_host(self, value):
        self._host = value
    host = property(_get_host, _set_host)
    def _get_port(self):
        return self._port
    def _set_port(self, value):
        self._port = value
    port = property(_get_port, _set_port)

    def create_session(self):
        response = self._post("/API/GetNewSession", params={})
        self._change_usersettings(session=response['session_id'])
        return response['session_id']

    def generate_image(self, params:dict, *, outfile="swarmctl-output.png",
        session:str):
        params['session_id'] = session
        params['images'] = 1
        for noise in ['swarm_version', 'rounding']:
            if noise in params:
                del params[noise]
        for fixup in ['loras', 'loraweights', 'loratencweights', 'lorasectionconfinement']:
            if fixup in params:
                _array2str(params, fixup)
        response = self._post("/API/GenerateText2Image", params=params,
            timeout=3600)
        imagefile = response['images'][0]
        self._download_image(imagefile, outfile)
        return(outfile)

    def get_file_params(self, file:str, verbose=False):
        """load image params from either a JSON file or image metadata"""
        base, ext = os.path.splitext(file)
        if ext.lower() == '.json':
            with open(file, "r") as jfile:
                return json.load(jfile)
        elif ext.lower() in ['.png', '.jpg', '.jpeg']:
            with Image.open(file) as image:
                metadata = image.info
                params = dict()
                if image.format == 'PNG':
                    if p := metadata["parameters"]:
                        if j := json.loads(p):
                            if sui := j["sui_image_params"]:
                                params = sui
                            if verbose:
                                params = j
                elif image.format == 'JPEG':
                    with open(file, "rb") as img:
                        tags = exifread.process_file(img, details=True)
                        if p := str(tags['EXIF UserComment']):
                            if j := json.loads(p):
                                if sui := j["sui_image_params"]:
                                    params = sui
                else:
                    print(f"{file}: no SwarmUI metadata found")
            return params
        else:
            print(f"{file}: unknown file type")

    def list_rules(self):
        return self._config.sections()

    def get_rule_params(self, rule:str):
        if self._config.has_section(rule):
            items = dict(self._config.items(section=rule))
            return items
        print(f"Warning: config file has no rule '{rule}'")
        return dict()

    def merge_params(self, sets:list):
        """merge multiple sets of parameters into one, keeping the last version of each key"""
        params = dict()
        for set in sets:
            for item in set:
                if set[item] == 'unset':
                    del params[item]
                else:
                    params[item] = set[item]
        return params

    def get_models(self, *, type='Stable-Diffusion', session:str):
        """retrieve the names of available models (base, lora, vae)"""
        params = {
            "session_id": session,
            "path": "",
            "depth": 4,
            "subtype": type # Stable-Diffusion, LoRA, VAE
        }
        response = self._post("/API/ListModels", params=params)
        return response['files']


    def _get(self, call:str, *, timeout=30):
        """Send GET request to a SwarmUI endpoint"""
        url = f"{self.baseurl}{call}"
        try:
            response = requests.get(url, timeout=timeout)
            response.raise_for_status()
        except requests.exceptions.RequestException as err:
            raise SystemExit(err)
        return response

    def _post(self, call:str, *, params:dict, timeout=5):
        """Send POST request with JSON parameters to a SwarmUI endpoint"""
        url = f"{self.baseurl}{call}"
        try:
            response = requests.post(url, json=params, headers=self._headers,
                timeout=timeout)
            response.raise_for_status()
        except requests.exceptions.RequestException as err:
            raise SystemExit(err)
        if 'error' in response.json():
            print(f"{call} failed: {response.json()['error']}")
        return response.json()

    # Warning: this API call always returns success; you *must* check
    # the server logs for failures.
    def _change_usersettings(self, *, session:str):
        """force specific filename format, as PNG, with metadata"""
        params = {
            'session_id': session,
            'settings': {
                'outpathbuilder.format': 'raw/[year]-[month]-[day]/[year][month][day]-[hour][minute][request_time_inc]-[model]-[prompthash]',
                'fileformat.imageformat': 'PNG',
                'fileformat.savemetadata': True
            }
        }
        response = self._post("/API/ChangeUserSettings", params=params)

    def _download_image(self, imagefile:str, outputfile:str):
        """download generated image from SwarmUI server"""
        response = self._get(f"/{imagefile}")
        with open(outputfile, mode="wb") as output:
            for chunk in response.iter_content(chunk_size=16*1024):
                output.write(chunk)

    # swarmui request format is slightly different from returned metadata
    # (array fields: loras, loraweights, lorasectionconfinement)
    # 
    def _array2str(d:dict, k:str):
        """convert d[k] from list to comma-separated string"""
        if type(d[k]) is list:
            d[k] = ','.join(d[k])
    def _str2array(d:dict, k:str):
        """convert d[k] from comma-separated string to list"""
        if type(d[k]) is str:
            d[k] = d[k].split(',')


@click.group()
@click.option('-h', '--host', default='localhost',
    help='server name or IP address')
@click.option('-p', '--port', default='7801',
    help='port server is listening on')
@click.option('-a', '--aspect', type=str,
    help='aspect ratio as X:Y or as specific XxY pixel resolution')
@click.option('-s', '--sidelength', default='1024/64',
    help='model sidelength as pixels/divisor (default 1024/64)')
#TODO: implement these
#@click.option('-f', '--format', default='png',
#    help='image format to save generated images (png|jpg, default png)')
#@click.option('-t', '--template', default='$pre-$set-$seq.$ext',
#    help='filename template for generated images (default "$pre-$set-$seq.$ext")')
@click.option('--pre', default='swarmui',
    help='template variable "pre"')
@click.option('--set', default='img',
    help='template variable "set"')
@click.option('--seq', default=1,
    help='template variable "seq" initial value (auto-increments)')
@click.option('--pad', default=4,
    help='zero-padding length for "seq" (default 4)')
def cli(host, port, aspect, sidelength, pre, set, seq, pad):
    pass

# in general, most params should be pulled from JSON files, config sections,
# or previous images; only overrides should be on cmdline

@cli.command()
@click.option('-m', '--model', type=str,
    help='base model to render images with')
@click.option('-l', '--loras', type=str, multiple=True,
    help='LoRA models to add (add ":0.x" to set strength < 1)')
@click.option('-p', '--params', multiple=True,
    help='a SwarmUI parameter and value as p=v (overrides argument)')
@click.option('-r', '--rules', multiple=True,
    help='config-file parameter set (overrides argument)')
@click.option('-n', '--dry-run', is_flag=True,
    help='just print the arguments that would be used to generate images')
@click.argument('sources', nargs=-1)
@click.pass_context
def gen(ctx, model, loras, params, rules, sources, dry_run):
    """
    Generate images with common parameters and different prompts.

    If an argument is a filename, read all metadata from it (accepts PNG,
    JPG, and JSON files) and use as params for generating an image.

    If one or more non-file arguments are passed, use them as separate
    prompts, and generate one image for each.

    If no arguments are passed, read prompts from STDIN and generate
    one image for each.
    """        

    s = swarmui(
        host=ctx.parent.params['host'],
        port=ctx.parent.params['port']
    )
    s.params = ctx.parent.params
    session_id = s.create_session()
    if sources:
        images = list(sources)
    else:
        images = sys.stdin.readlines()
    seq = s.params['seq']
    for image in images:
        if os.path.isfile(image):
            image_params = s.get_file_params(image)
            # store original filename in metadata
            # TODO: transfer to EXIF DocumentName on save
            image_params['personalnote'] = image
        else:
            image_params = { "prompt": image.rstrip() }
        if rules:
            for rule_arg in rules:
                for rule in rule_arg.split(','):
                    image_params = s.merge_params([image_params,
                        s.get_rule_params(rule)])
        if params:
            for param_arg in params:
                for param in param_arg.split(','):
                    k, v = param.split('=')
                    image_params[k] = v
        if model:
            image_params['model'] = model
        if loras:
            # TODO: extract optional weights from "lora:1" as string
            for lora in loras:
                if 'loras' not in image_params:
                    image_params['loras'] = list()
                image_params['loras'].append(lora)
                if 'loraweights' not in image_params:
                    image_params['loraweights'] = list()
                image_params['loraweights'].append("1")
        if s.params['aspect']:
            if s.params['sidelength']:
                if '/' in s.params['sidelength']:
                    sidelength, rounding = s.params['sidelength'].split('/')
                else:
                    sidelength = s.params['sidelength']
                    rounding = 64
                sidelength = int(sidelength)
            elif image_params['sidelength']:
                sidelength = int(image_params['sidelength'])
                if image_params['rounding']:
                    rounding = image_params['rounding']
                else:
                    rounding = 64
            width, height = get_aspect_pixels(s.params['aspect'],
                side=sidelength, rounding=int(rounding))
            image_params['width'] = width
            image_params['height'] = height
        outname = format_filename(pre=s.params['pre'],
            set=s.params['set'], pad=s.params['pad'], seq=seq)
        if dry_run:
            print(f"output file: {outname}")
            print(f"session_id: {session_id}")
            print(json.dumps(image_params, indent=4))
        else:
            image = s.generate_image(image_params, session=session_id,
                outfile=outname)
            print(outname)
        seq += 1
    
@cli.command()
@click.option('-j', '--json', 'json_output', is_flag=True,
    help='generate JSON output instead of default K=V')
@click.option('-v', '--verbose', is_flag=True,
    help='includes all metadata; implies --json')
@click.option('-p', '--prompt', is_flag=True,
    help='print just the prompt(s), one per line')
@click.argument('files', nargs=-1)
@click.pass_context
def params(ctx, json_output, verbose, prompt, files):
    """dump parameters from JSON, JPG, and PNG files"""
    if verbose:
        json_output = True
    s = swarmui()
    output = list()
    for file in files:
        params = s.get_file_params(file, verbose)
        if params:
            if prompt:
                print(params['prompt'])
            elif json_output:
                params['_filename'] = file
                output.append(params)
            else:
                print(f'filename={file}')
                for k in params:
                    print(f'{k}={params[k]}')
                if len(files) > 1:
                    print()
    if output:
        if len(output) > 1:
            print(json.dumps(output, sort_keys=True, indent=4))
        else:
            print(json.dumps(output[0], sort_keys=True, indent=4))

@cli.command()
@click.option('-v', '--verbose', is_flag=True,
    help='print contents of all rules for ~/.swarmctl')
@click.pass_context
def list_rules(ctx, verbose):
    """list all rules defined in ~/.swarmctl or default config"""
    s = swarmui()
    for rule in s.list_rules():
        if verbose:
            print(f"[{rule}]")
            keys = s.get_rule_params(rule)
            for k in keys:
                print(f"{k}={keys[k]}")
            print()
        else:
            print(rule)

@cli.command()
@click.option('-t', '--type', default='base', 
    help='model type (default "base")',
    type=click.Choice(['base', 'lora', 'vae']))
@click.option('-v', '--verbose', is_flag=True,
    help='print more detail about each model')
@click.argument('search', nargs=-1)
@click.pass_context
def list_models(ctx, type, verbose, search):
    """print list of available models"""
    subtype = 'Stable-Diffusion'
    match type:
        case 'lora':
            subtype = 'LoRA'
        case 'vae':
            subtype = 'VAE'
    s = swarmui(
        host=ctx.parent.params['host'],
        port=ctx.parent.params['port']
    )
    s.params = ctx.parent.params
    session_id = s.create_session()
    for model in s.get_models(type=subtype, session=session_id):
        found = True
        if search:
            found = False
            for key in ['name', 'architecture', 'compat_class']:
                if model[key] and search[0].casefold() in model[key].casefold():
                    found = True
        if found:
            if verbose:
                print(model['title'])
                for key in ['name', 'architecture', 'compat_class', 'resolution']:
                    if key in model:
                        print("    ", model[key])
            else:
                print(model['name'])

@cli.command()
@click.option('-n', '--dry-run', is_flag=True,
    help='just print the before/after filenames')
@click.argument('files', nargs=-1)
@click.pass_context
# TODO: add format override
def rename(ctx, dry_run, files):
    """
    rename files to use a consistent format based on --pre|set|seq;
    preserves existing file extension.
    """
    params = ctx.parent.params
    seq = params['seq']
    for file in files:
        base, ext = os.path.splitext(file)
        ext = ext.removeprefix('.')
        outname = format_filename(pre=params['pre'],
            set=params['set'], pad=params['pad'], seq=seq, ext=ext)
        if dry_run:
            print(file, outname)
        else:
            try:
                os.rename(file, outname)
            except Exception as e:
                print(f"rename '{file}' to '{outname}: {e}")
        seq += 1


def format_filename(*, pre="swarmui", set="img", seq=1,
    pad=4, ext="png"):
    """return a consistently-formatted filename for a sequenced image"""
    return f"{pre}-{set}-{str(seq).zfill(pad)}.{ext}"


def get_aspect_pixels(ratio:str, *, side=1024, rounding=64):
    """calculate best XxY-pixel approximation for aspect ratio"""
    if 'x' in ratio:
        # user requested specific width x height
        width, height = [int(x) for x in ratio.split('x')]
        return width, height
    elif ':' not in ratio:
        a_w = 1.0
        a_h = 1.0
    else:
        a_w, a_h = [int(x) for x in ratio.split(':')]
    scale = math.sqrt(side * side / (a_w * a_h))
    ideal_w = a_w * scale
    ideal_h = a_h * scale
    width = int(ideal_w) - (int(ideal_w) % rounding)
    height = int(ideal_h) - (int(ideal_h) % rounding)
    while width * height > side * side and width > 0 and height > 0:
        if width >= height:
            width -= rounding
        else:
            height -= rounding
    return width, height


if __name__ == '__main__':
    cli()
